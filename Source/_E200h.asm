	#include "equates.inc"
	.ORG    S_BDOS	;0E200h
;	#DEFINE D_E9AC L_E9AB+1		; адрес области для контроля за заполнением диска С:
	#DEFINE D_E9AD D_E9AC+21h	; адрес области для контроля за заполнением диска Д:
	#DEFINE D_E9CD D_E9AD+21h	; адрес области для контроля за заполнением диска А:
	#DEFINE D_EA00 D_E9CD+33h	; адрес области для контроля за заполнением диска В:
	#DEFINE D_EA33 D_EA00+33h	; адрес области используемой для контроля смены диска А:
	#DEFINE D_EA53 D_EA33+20h	; адрес области используемой для контроля смены диска В:
	#DEFINE D_EA73 D_EA53+20h	; адрес 128 байтного буфера для операций с директорием
	#DEFINE D_EB00 D_EA73+80h	; адрес буфера для НЖМД 512Б
	#DEFINE D_FD_B 0BC00h	; адрес буфера для флопиков 1кБ, изначально EB00-EEFF
;
	#DEFINE D_E962 00000h	; затычка, эта таблица более не используется
;
	#DEFINE M_FFC4 0FFC4h	; скорость записи на магнитную ленту
	#DEFINE M_FFC5 0FFC5h	; скорость считывания с магнитной ленты
;
L_E200: JMP     L_IHDD	; инициализация БДОС (L_E225)
L_E203: JMP     L_IFHD	; горячий рестарт БДОС (L_E225)
L_E206: JMP     L_E236	; статус консоли (клавиатуры), принтера и доп.устр.
L_E209: JMP     L_E23F	; ввод символа с клавиатуры, принтера или м.л.(RET)
L_E20C: JMP     L_E248	; вывод символа на экран, принтер или м.л.(RET)
L_E20F: JMP     L_E251	; возвращает адрес DPH области для дисковода
L_E212: JMP     L_E2E4	; обмен с дисковыми устройствами	; (было E2CA) адрес меняется на E2C4 !!!
L_E215: JMP     L_E61A	; возврат ссылки на таблицы со строками текст.сообщений
L_E218: JMP     L_E291	; обработка команд пользователя (выполнение цифровых команд мдос)
L_E21B: JMP     L_E5D4	; форматирование КД C:
L_E21E:	JMP     L_E224	; // патч перехода по L_E212
L_E221:	MVI  A, 003h	; // отключение второго КД
	STA     LxE255+1; записываем, что дисков три.
	STA     LxE5DZ+1; и в подпрограмму форматирования/тестирования КД
	RET
;
L_E224:	LXI  H, L_E2C4	; меняем адрес в L_E212 на этот...
	SHLD    L_E212+1
	RET
;
;; === ПП начальной инициализации НЖМД ===
L_IHDD:
#ifndef NoHDD
	XRA  A
	STA     L_RWD	; режим чтения, =0 (метка "требуется запись буфера" =0)
	STA     L_E86F	; сектор, =0
	CMA		; A = 0FFh
	STA     L_E86D	; дорожка, =-1 (FFh)
	STA     L_DSKT+1	; делаем заведомо большой номер дискеты, 0FFxxh
	CALL    L_RWHD	; -->> грузит сектор в буфер
	PUSH PSW
	JNZ     L_EHDD	; не получилось -- отключаем НЖМД
	LHLD    D_EB00+084h	; читает из буфера количество дискет на НЖМД
#else
	XRA  A
	DCR  A
	PUSH PSW	; код возврата FF и Z=0
	JMP     L_EHDD	; отключаем НЖМД
#endif
L__HDD:	MOV  A, H	; инверсия HL
	CMA
	MOV  H, A
	MOV  A, L
	CMA
	MOV  L, A
	SHLD    LxDMAX+1	; -- патч на максимальное количество дискет НЖМД
	POP  PSW	; загружаем код возврата при обращении к НЖМД
	RET
;
L_EHDD: LXI  H, 00000h	; НЖМД не определился
	SHLD    T_DrvA	; обнуляем номер дискеты в А:
	SHLD    T_DrvB	; обнуляем номер дискеты в Б:
	JMP     L__HDD  ; выход
;
; ------------------- END init HDD ---------------
;
L_E236: CALL    L_E2A8	; вызов PCHL (1) со значением HL далее:
; ссылки для PCHL (1), адрес начала берётся из адреса возврата CALL
	.dw     B_F812	; 00	; статус клавиатуры
	.dw     L_E617	; 01	; А=1 и RET
	.dw     L_E615	; 02	; А=0 и RET
;
L_E23F: CALL    L_E2A8	; вызов PCHL (1) со значением HL далее:
; ссылки для PCHL (1), адрес начала берётся из адреса возврата CALL
	.dw     B_F803	; 00	; ввод символа с клавиатуры
	.dw     L_E615	; 01	; А=0 и RET
	.dw     B_F806	; 02	; ввод байта с м/л -- сразу RET
;
L_E248: CALL    L_E2A8	; вызов PCHL (1) со значением HL далее:
; ссылки для PCHL (1), адрес начала берётся из адреса возврата CALL
	.dw     B_F809	; 00	; вывод символа на экран
	.dw     B_F80F	; 01	; вывод символа на принтер
	.dw     B_F80C	; 02	; вывод байта на м/л -- сразу RET
;
L_E251: LXI  H, 00000h	; ПП возвращает адрес DPH области для дисковода
	MOV  A, C
LxE255:	CPI     004h	; << тут определяется количество дисков в системе!
	RNC		; возврат, если больше или равно 4
	CALL    L_E2B6	; заносим значение из (сл.адрес + А + А)
			; в HL и делаем RET (предыдущий вызов? 0DC1Eh)
T_PDH:	.dw T_E261	; 00
	.dw T_E271	; 01
	.dw T_E281	; 02
	.dw T_E291	; 03
;
T_E261: .dw D_E962	; 00 адрес таблицы трансляции логических секторов в физические (передается функции SECTRAN в DE) или 0 если трансляция не нужна
	.dw 00000h	; 01 просто ноль
	.dw 00000h	; 02 просто ноль
	.dw 00000h	; 03 просто ноль
	.dw D_EA73	; 04 адрес 128 байтного буфера для операций с директорием. Это поле у всех DPH в системе может совпадать.
	.dw D_E935	; 05 адрес таблицы параметров диска. Допускается совместное использование одной и той же таблицы разными DPH.
	.dw D_EA33	; 06 адрес области используемой для контроля смены диска. Для каждого DPH в системе должна быть своя область.
	.dw D_E9CD	; 07 адрес области для контроля за заполнением диска. Для каждого DPH в системе должна быть своя область.

T_E271: .dw D_E962	; 00
	.dw 00000h	; 01
	.dw 00000h	; 02
	.dw 00000h	; 03
	.dw D_EA73	; 04	адрес буфера для дисковых операций
	.dw D_E935	; 05	// было D_E944
	.dw D_EA53	; 06
	.dw D_EA00	; 07

T_E281: .dw D_E962	; 00
	.dw 00000h	; 01
	.dw 00000h	; 02
	.dw 00000h	; 03
	.dw D_EA73	; 04	адрес буфера для дисковых операций
	.dw D_E953	; 05
	.dw 00000h	; 06
	.dw D_E9AC	; 07

T_E291: .dw D_E962	; 00
	.dw 00000h	; 01
	.dw 00000h	; 02
	.dw 00000h	; 03
	.dw D_EA73	; 04	адрес буфера для дисковых операций
	.dw D_E953	; 05
	.dw 00000h	; 06
	.dw D_E9AD	; 07
;
L_E291: CALL    L_E2B1
; ссылки для PCHL (1), адрес начала берётся из адреса возврата CALL
; (выполнение цифровых команд мдос)
	.dw P_E426	; 00 -- команда "0"		устанавливает параметры ввода/вывода
	.dw P_E526	; 01 -- команда "1"		запись файла из оперативной памяти на диск
	.dw P_E5CF	; 02 -- команда "2" (RET)	копирует файлы с магнитной ленты на диск
	.dw P_E5CF	; 03 -- команда "3" (RET)	записывает файлы с диска на магнитную ленту
	.dw P_E5CF	; 04 (RET)		+++++++	+ просмотр и указание пути поиска файлов
	.dw P_E5BB	; 05 -- команда "5"		переименовыает файлы
	.dw P_E5CF	; 06 (RET)		+++++++	+ сброс признаков файла
	.dw P_E5CF	; 07 (RET)		+++++++	+ установка признаков файлов
	.dw P_E5D0	; 08 -- команда "8"		проверка/форматирование электронного диска
	.dw P_Ex01	; 09 -- команда "9" (доб.)	назначение дискет НЖМД на диски А: и Б:
;
L_E2A8: POP  H		; считать адрес возврата
	MOV  A, D
	CPI     003h	; если D < 3
	JC      L_E2B2	; вызываем pchl(1) на адрес из таблицы
	XRA  A		; иначе обнуляем А и возврат
	RET
;
L_E2B1:	POP  H
L_E2B2: CALL    L_E2B7	; заносим в HL значение из адреса HL	;-)
	PCHL		; >>>> (1)
;
L_E2B6: POP  H
L_E2B7:	ADD  A
	ADD  L
	MOV  L, A
	JNC     L_E2BE
	INR  H
L_E2BE: MOV  E, M
	INX  H
	MOV  H, M
	MOV  L, E
	RET
;
; ===== обмен с дисковыми устройствами ============================
L_E2C4: LXI  D, L_E98A	; перенос описателя дисковой операции
	MOV  C, M	; C = номер диска (диск А = 0, диск В = 1...)
	MVI  B, 008h
L_E2CF: MOV  A, M
	STAX D
	INX  H
	INX  D
	DCR  B
	JNZ     L_E2CF	; цикл 8 раз, читаем с adr(HL), пишем в L_E98A++
	MOV  A, C	; номер диска (диск А = 0, диск В = 1...)
	CPI     002h
	JNC     L_KD	; >> обращение к КД, если Диск >= 2
	CALL    LaD9B2	; получение ссылки на таблицу замены дискеты на НЖМД, в А номер диска
	MOV  A, M
	MOV  E, A
	INX  H
	MOV  D, M
	INX  H		; DE = номер дискеты, HL = ссылка на таблицу НЖМД +2
	ORA  D		; DE = 0 -- флоповод, не 0 -- НЖМД
	JZ      L_E716	; >>>>>>>>>>>>>>>>>>> обращение к флопикам
#ifndef NoHDD
	XCHG		; в HL номер дискеты
	SHLD    L_DSKT	; сохраняем номер дискеты (используется только для проверки актуальности данных в буфере)
	LDA     L_BDS	; дискета,мл.б	(данных в буфере)
	CMP  L
	JNZ     L_RW0	; >> не совпало
	LDA     L_BDS+1	; дискета,ст.б	(данных в буфере)
	CMP  H
	JZ      L_RW1	; >> совпало
L_RW0:	PUSH D		; в стек ссылку на таблицу НЖМД +2
	LDA     L_RWD	; смотрим метку "требуется запись буфера"
	ANA  A		; признаки по А, A<>0 -- требуется запись.
	CNZ     L_RWHD	; обращение к диску с предыдущими установками, запись
	POP  H		; HL = ссылка на таблицу НЖМД +2
	RNZ		; выход в случае ошибки
	SHLD    L_1SEC	; сохранение ссылки на таблицу НЖМД +2
	MVI  B, 0FFh	; в В метка, что диск не совпал (иначе будет В=0)
L_RW1:	LHLD    L_BDR	; H = (сектор-1)/4 в буфере; L = дорожка в буфере
	LDA     L_E98E	; номер дорожки диска МДОС
	MOV  E, A
	LDA     L_E98F	; номер сектора диска МДОС
	DCR  A
	ANI     0FCh	; 1111 1100
	RRC
	RRC		; А = (сектор-1)/4	(запрос)
	MOV  D, A
	SUB  H
	JNZ     L_RW2	; >> не совпал сектор
	CMP  B		; проверяем метку совпадения диска
	JNZ     L_RW3	; >> не совпадал диск (в этом случае сброс буфера уже был)
	MOV  A, E
	CMP  L		; проверяем дорожку
	JZ      L_RWBF	; >> всё совпало, работаем с буфером
L_RW2:	PUSH D		; D = (сектор-1)/4 (запрос); E = дорожка (запрос)
	LDA     L_RWD	; смотрим метку "требуется запись буфера"
	ANA  A		; признаки по А, A<>0 -- требуется запись.
	CNZ     L_RWHD	; обращение к диску с предыдущими установками, запись
	POP  D
	RNZ		; выход в случае ошибки
L_RW3:	MOV  A, D	; обновление данных в буфере с диска
	STA     L_E86F	; сохр. (сектор-1)/4	(запрос)
	MOV  A, E
	STA	L_E86D	; сохр. дорожку		(запрос)
	XRA  A		; обнуляем данные в буфере:
	STA     L_BDR	; дорожка
	STA     L_BSC	; (сектор-1)/4
	STA     L_RWD	; уст.режим чтения (=0)
	CMA		; A = FFh
	STA     L_BDS+1	; дискета = 0FFxxh, больше максимального значения
	CALL    L_RWHD	; обращение к диску (обновление буфера) -- только чтение!
	RNZ		; >>> выход, если были ошибки
	; переброска 128 байт из буфера D_EB00 в L_E990 (или наоборот при записи)
L_RWBF:	LXI  D, D_EB00	; буфер
	LDA     L_E98F	; сектор МДОС дискеты
	DCR  A
	ANI     003h	; (сектор-1) mod 4
	RAR		; ((сектор-1) mod 4) / 2, нулевой разряд в признак С
	MOV  H, A
	MVI  A, 000h
	RAR		; A = <C>000 0000b
	MOV  L, A	; HL = ((сектор-1) mod 4) * 128
	DAD  D		; HL -- начало данных в буфере для переброски
	LDA     L_E98C	; чтение(04h)/запись(06h)
	SUI     006h	; если запись, то А = 0 и Z = 1
	PUSH PSW	; сохраняем результат проверки в стек
	CALL    L_MBUF	; переброска данных из/в дисковый буфер МДОС
	POP  PSW	; из стека, если запись, то А = 0 и Z = 1
	JNZ	L_EXI	; НЕ запись -> выход
	CMA
	STA     L_RWD	; (=FFh), ставим метку "нужна запись буфера"
	LDA     L_E98F	; сектор МДОС дискеты
	ANI     003h	; (сектор) mod 4, последний сектор в кластере?
	CZ      L_RWHD	; если да -> обращение к диску, запись
L_EXI:	LDA     L_E873	; код возврата чтения/записи диска
#endif
	ANA  A
	RET
;
	; HL -- откуда брать/куда сохранять
	; Z=0 -- запись
L_MBUF:	XCHG		; DE = начало данных
	LHLD    L_E990	; адрес буфера дисковой операции
	JNZ     L_NWR	; НЕ запись
	XCHG
L_NWR:	PUSH H		; адрес буфера дисковой операции в стек
	MVI  C, 040h	; счётчик на 64 (= 128 байт /2)
	LXI  H, 00002h
	DAD  SP		; HL = SP + 2
	SHLD    LxPSP+1	; HL заносим в установку адреса стека
	XCHG
	POP  D
	DI
	SPHL		; УС = откуда брать данные
	XCHG		; HL = куда записывать
L_ML1:	POP  D
	MOV  M, E
	INX  H
	MOV  M, D
	INX  H
	DCR  C
	JNZ     L_ML1
LxPSP:	LXI  SP,00000h	; адрес меняется!!!
	EI
	RET
;
; ===== КД ========================================================
L_KD:	LDA     L_E98C	; чтение(04h)/запись(06h)
	CPI     004h
	JZ      L_E332	; чтение сектора КД в дисковый буфер
	CPI     006h
	JZ      L_E39B	; запись сектора КД из дискового буфера
L_E2E4:	XRA  A
;	ANA  A
	RET
;
; ----- КД ----- 	; чтение сектора КД в дисковый буфер
L_E332: CALL    L_E3DB	; вычисление режима и адреса КД по дорожке и сектору
	LXI  H, 00000h
	DAD  SP		; SP => HL
	SHLD    L_E38X+1	; HL заносим в установку адреса стека
	LHLD    L_E992	; HL= адрес сектора КД
	MVI  A, 080h
	ADD  L
	MOV  L, A
	JC      L_E347
	DCR  H		; HL+128 байт
L_E347: DI
	SPHL
	LHLD    L_E990	; считываем адрес буфера для дисковых операций
	MVI  C, 020h	; счётчик, 20h*4 = 128 байт (1 сектор)
	XRA  A		; отключаем первый КД
	OUT     010h	; отправляем на квазидиск
	LDA     L_E98A  ; считываем номер диска
	ADI     00Eh
        STA     L_E352+1; патчим в программе номер порта, 10h / 11h
        STA     L_E37X+1;
;	CPI     002h	; = 2?
	LDA     L_E994	; конфиг.КД
;	JZ      L_E352
;	OUT     011h	; второй КД
;	JMP     L_E353
L_E352:	OUT     010h	; отправляем на квазидиск <<< номер порта меняется!
L_E353:	XRA  A
L_E354: POP  D
	MOV  M, E
	ADD  E
	INX  H
	MOV  M, D
	ADD  D
	INX  H
	POP  D
	MOV  M, E
	ADD  E
	INX  H
	MOV  M, D
	ADD  D
	INX  H
	DCR  C
	JNZ     L_E354
	MOV  B, A	; B = контрольная сумма
	MVI  A, 01Fh	; 0001 1111 -- банк 0 как СТЕК
L_E37X:	OUT     010h	; отправляем на квазидиск <<< номер порта меняется!
L_E37Y:	LHLD    L_E995	; адрес контрольной суммы сектора КД
	SPHL
	POP  D
	MOV  A, E
	CMP  D
	JNZ     L_E37E
	CMP  B
	JZ      L_E38A
	MVI  C, 002h	; КС не совпадает?
	JMP     L_E38A
;
L_E37E: CMP  B
	JZ      L_E388
	MOV  A, D
	CMP  B
	MOV  E, D
	JZ      L_E389
	MVI  C, 003h
	JMP     L_E38A
L_E388: MOV  D, E
L_E389: PUSH D		; запись контрольной суммы на КД
L_E38A: XRA  A
	OUT     011h	; отключаем второй диск, в любом случае
L_E38X:	LXI  SP,00000h	; адрес меняется !!!
	MVI  A, 023h	; 0010 0011b -- банк 0 как ОЗУ A000-DFFFh
	OUT     010h	; отправляем на квазидиск
	EI
	MOV  A, C
	ANA  A
	RET
;
; ----- КД -----	; запись сектора КД из дискового буфера
L_E39B: CALL    L_E3DB	; вычисление режима и адреса КД по дорожке и сектору
	LXI  D, 0007Fh  ; размер сектора - 1
	LXI  H, 00000h
	DAD  SP		; SP => HL
	SHLD    L_E38X+1	; HL заносим в установку адреса стека
	LHLD    L_E992
	DI
	SPHL
	LHLD    L_E990	; адрес буфера для дисковых операций
	DAD  D
	MVI  C, 020h
	XRA  A		; отключаем первый КД
	OUT     010h	; отправляем на квазидиск
	LDA     L_E98A  ; считываем номер диска
	ADI     00Eh
        STA     L_E3B7+1; патчим в программе номер порта, 10h / 11h
        STA     L_E3DX+1;
	LDA     L_E994	; конфиг.КД
L_E3B7:	OUT     010h	; отправляем на квазидиск <<< номер порта меняется!
L_E3B8:	XRA  A
L_E3B9: MOV  D, M
	ADD  D
	DCX  H
	MOV  E, M
	ADD  E
	DCX  H
	PUSH D
	MOV  D, M
	ADD  D
	DCX  H
	MOV  E, M
	ADD  E
	DCX  H
	PUSH D
	DCR  C
	JNZ     L_E3B9
	MOV  D, A
	MVI  A, 01Fh	; 0001 1111 -- банк 0 как СТЕК
L_E3DX:	OUT     010h	; отправляем на квазидиск <<< номер порта меняется!
L_E3DY:	LHLD    L_E995	; адрес контрольной суммы сектора КД
	SPHL
	POP  H		; считывание взамен SP = SP + 2
	MOV  E, D
	JMP     L_E389
;
; ----- КД -----	; вычисление режима и адреса КД по дорожке и сектору
; вход:		L_E98E -- номер дорожки КД, L_E98F -- номер сектора КД
; выход:	L_E994 -- конфиг.КД, L_E992 -- адрес на КД,
;		L_E995 -- адрес контрольной суммы сектора КД
;
L_E3DB: LDA     L_E98E	; номер дорожки КД
	MVI  H, 0ECh
	CPI     004h
	JNC     L_E3E7	; если дорожка >= 4
	MVI  H, 0FCh
L_E3E7: SUB  H		; A = номер_дорожки - H
	CMA
	RLC
	RLC
	MOV  H, A
	RLC
	RLC
	ANI     00Ch	; 0000 1100
	ORI     033h	; 0011 0011	010h	; 0001 0000 //
	STA     L_E994	; конфиг.КД
	MVI  A, 003h
	ORA  H
	MOV  H, A	; H = ст.байт адреса
	MVI  L, 0FFh
	INX  H
	LDA     L_E98F	; номер сектора КД
	LXI  D, 0FF80h	; -------
L_E402: DCR  A
	JZ      L_E40A
	DAD  D
	JMP     L_E402
;
L_E40A: SHLD    L_E992	; адрес на КД
	LDA     L_E98E	; номер дорожки КД
	MOV  L, A
	MVI  H, 000h
	DAD  H
	DAD  H
	DAD  H
	DAD  H
	LDA     L_E98F	; номер сектора КД
	DCR  A
	ADD  A
	ADD  L
	MOV  L, A
	LXI  D, 0F000h	; --------
	DAD  D
	SHLD    L_E995	; адрес контрольной суммы сектора КД
	RET
;
; ----- КД ----- тестирование/форматирование <<<-- команда "8"
P_E5D0:	LDA     A_005C	; первый аргумент выполняемой команды (если это диск)
	ANA  A
	JNZ     L_E5DY	; >> аргумент не нулевой
	MVI  A, 003h	; устанавливаем диск С:, если диск не был указан
	STA     A_006C+1; и затираем второй аргумент выполняемой команды, на всякий случай
L_E5DY:	CPI     003h	; < "C:"?
	JC      L_E457	; >> вывод "неверное имя" и RET
	DCR  A
LxE5DZ:	CPI     004h	; > "D:"?  << тут правится значение при осутствии Д:
	JNC     L_E457	; >> вывод "неверное имя" и RET
	STA     L_E98A  ; записываем номер диска
	LDA     A_006C+1; второй аргумент выполняемой команды
	CPI     046h	; = "F" ?
	MVI  A, 004h	; (чтение с КД)
	JNZ     L_E5D7	; нет, >> тест КД
	CALL    L_E5D5	; вызов форматирования КД
	MVI  C, 00Dh	; Сброс дисковой системы
	JMP     00005h	; <<<<<< и выход
;
L_E5D4:	MVI  A, 002h	; <<< начальное форматирование КД С:
	STA     L_E98A  ; записываем номер диска С:
L_E5D5: MVI  A, 006h	; (запись на КД) <<< форматирование КД
L_E5D7: STA     L_E98C	; чтение(04h)/запись(06h)
	LXI  D, 00008h
	LXI  H, D_EA73	; -----------
	SHLD    L_E990	; сохр. адрес буфера для дисковых операций
	MVI  C, 080h
	MVI  A, 0E5h
L_E5E7: MOV  M, A
	INX  H
	DCR  C
	JNZ     L_E5E7	; заполняем буфер значением "E5"
L_E5F2: MOV  A, E
	STA     L_E98F	; номер сектора КД
	MOV  A, D
	STA     L_E98E	; номер дорожки КД
	PUSH D
	LXI  H, L_E98A
	CALL    L_E2C4	; дисковые операции, == E212
	CNZ     L_E2E7	; вывод ошибки чтения/записи
	POP  D
	DCR  E
	JNZ     L_E5F2	; цикл по секторам
	MVI  E, 008h
	INR  D
	MOV  A, D
	CPI     0ECh	; общее число дорожек КД
	JNZ     L_E5F2	; цикл форматирования/тестирования
	CALL    L_E5B2	; вывод "Ok"
	XRA  A
	RET
;
L_E2E7: PUSH PSW	; вывод ошибки чтения/записи КД
	LXI  H, L_E98A
	LXI  D, L_E305	; >> строки "ER=..."
	MVI  B, 009h
L_E2F0: XCHG
	PUSH PSW
	CALL    B_F818	; вывод сообщения на экран (должно оканчиваться 0 байтом)
	POP  PSW
	XCHG
	PUSH B
	CALL    B_F815	; вывод байта на экран 16-ричном виде
	POP  B
	MOV  A, M
	INX  H
	INX  D
	DCR  B
	JNZ     L_E2F0
	POP  PSW
	RET
;
L_E305: .db 00Dh, 00Ah, "ER=", 000h
	.db " D=", 000h			;(offset 020Bh)
	.db " CHW=", 000h		;(offset 0210h)
	.db " OP=", 000h		;(offset 0216h)
	.db " NS=", 000h		;(offset 021Bh)
	.db " T=", 000h			;(offset 0220h)
	.db " S=", 000h			;(offset 0224h)
	.db " A2=", 000h		;(offset 0228h)
	.db " A1=", 000h		;(offset 022Dh)
;
; =================================
;
			; обработка "0" -- устанавливает параметры ввода/вывода
P_E426: ;CALL    L_E6DE	; /перевод строки/ <<<<<<<< внешний вызов из 0DA91h
	LXI  D, A_005C+1; первый аргумент выполняемой команды
	LDAX D
	CALL    L_E4BA
	LXI  D, A_006C+1; второй аргумент выполняемой команды
	LDAX D
	CPI     052h	; = "R" ?
	JZ      L_E45E	; уст.скорости считывания с магнитной ленты
	CPI     057h	; = "W" ?
	JZ      L_E463	; уст.скорости записи на магнитную ленту
	CPI     041h	; = "A" ?
	JZ      L_E468	; выводит на дисплей управляющую последовательность 1Вh,L
	CPI     050h	; = "P" ?
	JZ      L_E474	; уст.цвета отображения и цвет фона
;;	CPI     04Dh	; = "M" ?
;;	JZ      L_E483	; устанавливает режим печати
;	CPI     053h	; = "S" ?
;	JZ      L_E4A2	; нечто патчится в ПП для флоповода ??????
;	CPI     056h	; = "V" ? --  было 057h, а это не сработает никогда...
;	JZ      L_E4B6	; ещё патчи ПП для флоповода ?????
L_E457: LXI  D, S_E6A5	; >>"Неверное имя$"
	JMP     L_E6E1	; Вывод последовательности символов (до "$")
;	RET
;
L_E45E: MOV  A, L
	STA     M_FFC5	; >>> скорость считывания с магнитной ленты
	RET
;
L_E463: MOV  A, L
	STA     M_FFC4	; >>> скорость записи на магнитную ленту
	RET
;
L_E468: PUSH H		; выводит на дисплей управляющую последовательность 1Вh,L
	MVI  C, 01Bh
L_E46B: CALL    B_F809	; >>>>>>>>
	POP  H
	MOV  C, L
	CALL    B_F809	; >>>>>>>>
	RET
;
L_E474: PUSH H		; уст.цвета отображения и цвет фона
	MVI  C, 01Bh
	CALL    B_F809	; >>>>>>>>
	MVI  C, 050h
	CALL    B_F809	; >>>>>>>>
	MOV  C, H
	JMP     L_E46B
;
;L_E483: MOV  A, L	; устанавливает режим печати
;	STA     L_E49C
;	MOV  A, H
;	STA     L_E4A0
;	LXI  H, L_E49A
;	MVI  B, 008h
;L_E490: MOV  C, M
;	CALL    B_F80F	; >>>>>>>> вывод символа на принтер
;	INX  H
;	DCR  B
;	JNZ     L_E490
;	RET
;
;L_E49A: .db 01Bh	; некие управляющие символы для принтера
;	.db 033h	;
;L_E49C: .db 012h	;
;	.db 01Bh	;
;	.db 043h	;
;	.db 000h	;
;L_E4A0: .db 00Ch	;
;	.db 007h	;
;
;L_E4A2: XRA  A	; нечто патчится в ПП для флоповода ??????
;	ORA  L
;	JZ      L_E4AA
;	DCR  L
;	MVI  A, 047h	; = MOV B,A
;L_E4AA: STA     L_E83A	; !!! изменение программы !!!
;	MVI  A, 003h
;	ANA  L
;	ORI     010h
;	STA     LxE86F+1	; !!! изменение программы !!!
;	RET
;
; -- а это не работало никогда...
;L_E4B6: SHLD    LxE847+1	; !!! изменение программы !!!
;	RET
;
L_E4BA: LXI  H, 00000h
L_E4BD: LDAX D
	INX  D
	CPI     020h
	RZ
	SUI     030h
	JM      L_E4E4
	CPI     00Ah
	JM      L_E4D8
	CPI     011h
	JM      L_E4E4
	CPI     017h
	JP      L_E4E4
	SUI     007h
L_E4D8: MOV  C, A
	DAD  H
	DAD  H
	DAD  H
	DAD  H
	JC      L_E4E4
	DAD  B
	JMP     L_E4BD
;
L_E4E4: CALL    L_E457	; вывод "Неверное имя"
;	LXI  D, A_005C	; первый аргумент выполняемой команды (нач.с нуля)
	CALL    L_E6EB	; Закрытие файла
	STC
	RET
;
L_E4EF: PUSH H
	PUSH B
	XCHG
	MVI  C, 01Ah	; Установка адреса буфера ПДП
	CALL    00005h
	LXI  D, A_005C	; первый аргумент выполняемой команды (нач.с нуля)
	MVI  C, 015h	; Последовательная запись
	CALL    00005h
	LXI  D, L_E502	; "диск полный"
	ORA  A
	POP  B
	POP  H
	RET
;
L_E502: .db 0E4h	; <Д>
	.db 0C9h	; <и>
	.db 0D3h	; <с>
	.db 0CBh	; <к>
	.db 020h	; < >
	.db 0D0h	; <п>
	.db 0CFh	; <о>
	.db 0CCh	; <л>
	.db 0CEh	; <н>
	.db 0D9h	; <ы>
	.db 0CAh	; <й>
	.db 024h	; <$>
;
S_E50D: .db 00Dh	; <_>
	.db 00Ah	; <_>
S_E50E: .db 0E4h	; <Д>
	.db 0C9h	; <и>
	.db 0D2h	; <р>
	.db 0C5h	; <е>
	.db 0CBh	; <к>
	.db 0D4h	; <т>
	.db 0CFh	; <о>
	.db 0D2h	; <р>
	.db 0C9h	; <и>
	.db 0D1h	; <я>
	.db 020h	; < >
	.db 0D0h	; <п>
	.db 0CFh	; <о>
	.db 0CCh	; <л>
	.db 0CEh	; <н>
	.db 0C1h	; <а>
	.db 0D1h	; <я>
	.db 024h	; <$>
;
S_E520: .db 00Dh	; <_>
	.db 00Ah	; <_>
	.db 020h	; < >
	.db 04Fh	; <O>
	.db 06Bh	; <k>
	.db 024h	; <$>
;
P_E526: ;CALL    L_E6DE	; <<<<< внешний вызов на "1" (Ответ: "Неверное имя")
	LXI  D, A_005C+1; первый аргумент выполняемой команды
	CALL    L_E4BA	; в HL переводится аргумент в HEX
	RC
	XRA  A
	CMP  L		; в L количество блоков
	JZ      L_E457	; вывод "Неверное имя" и RET
	SHLD    L_E5B9
	LXI  D, A_005C	; первый аргумент выполняемой команды (нач.с нуля)
	LXI  H, A_006C	; второй аргумент выполняемой команды (нач.с нуля)
	MOV  A, M
	STAX D
	INX  H
	INX  D
	MVI  B, 00Bh
L_E544: MOV  A, M
	STAX D
	ANI     07Fh
	CPI     000h	; = 00h ?
	JZ      L_E56B	; идём далее...
	CPI     020h	; = " " ?
	JZ      L_E56B	; идём далее...
	CPI     03Fh	; = "?" ?
	JZ      L_E457	; вывод "Неверное имя" и RET
	CPI     05Bh	; >= "[" ?
	JNC     L_E457	; вывод "Неверное имя" и RET
	CPI     041h	; >= "A" ?
	JNC     L_E56B	; идём далее...
	CPI     02Fh	; < "/" ?
	JC      L_E457	; вывод "Неверное имя" и RET
	CPI     03Ah	; >= ":" ?
	JNC     L_E457	; вывод "Неверное имя" и RET
L_E56B: INX  D
	INX  H
	DCR  B
	JNZ     L_E544
	MVI  B, 019h
L_E573: XRA  A
	STAX D
	INX  D
	DCR  B
	JNZ     L_E573	; выше в цикле проверяется и переносится в первый аргумент имя файла
	LXI  D, A_005C	; первый аргумент выполняемой команды (нач.с нуля)
	MVI  C, 013h	; Удаление файла
	CALL    00005h
	LXI  D, A_005C	; первый аргумент выполняемой команды (нач.с нуля)
	MVI  C, 016h	; Создание файла
	CALL    00005h
	LXI  D, S_E50D	; >> "Директория полная"
	INR  A
	JZ      L_E6E1	; Вывод последовательности символов (до "$") и RET
	LDA     L_E5B9
	MOV  B, A
	LXI  H, 00100h
L_E594: CALL    L_E4EF
	JNZ     L_E6E1	; Вывод последовательности символов (до "$") и RET
	LXI  D, A_0080	; аргумент выполняемой команды (<ДЛ>< ><строка>)
	DAD  D
	CALL    L_E4EF
	JNZ     L_E6E1	; Вывод последовательности символов (до "$") и RET
	LXI  D, A_0080	; аргумент выполняемой команды (<ДЛ>< ><строка>)
	DAD  D
	DCR  B
	JNZ     L_E594
	CALL    L_E6EB	; Закрытие файла
L_E5B2:	LXI  D, S_E520	; >> "Ok"
	JMP     L_E6E1	; Вывод последовательности символов (до "$") и RET
;	RET
;
L_E5B9: .dw 00000h	; (offset 04B9h)
;
P_E5BB: LXI  D, A_005C	; первый аргумент выполняемой команды (нач.с нуля)	; <<<<<-- вызов из 0DA91h на команду 5
	MVI  C, 017h	; Переименование файла
	CALL    00005h
	CPI     004h
	JC      L_E5B2	; вывод "Ok" и RET
	JMP     L_E457	; вывод "Неверное имя" и RET
;
P_E5CF: RET		; <<<<<<-- вызов из 0DA91h на команды 2 и 3
;
L_E615: XRA  A
	RET
;
L_E617: MVI  A, 001h
	RET
;
L_E61A: LXI  H, L_E61E
	RET
;
; Ссылки на строки:
L_E61E: .dw LsE638	; "Ошибка БСВВ на $"		<<< 0DA05h, на "E:" (1)
LsE620: .dw LsE648	; " ошибка диска$"
LsE622: .dw LsE656	; "$"			       <<< 0DA05h, на "E:" (2)
LsE624: .dw LsE657	; " файл только для чтения$"
LsE626: .dw LsE6C1	; #0d #0a "Удалять (Y/N)? $"	<<< 0DA05h, на "E *.*"
LsE628: .dw LsE67F	; " $"
LsE62A: .dw LsE681	; "Игнорировать (Y/N)? $"
LsE62C: .dw LsE696	; " Файл уже есть$"
LsE62E: .dw LsE66F	; " системный файл$"
LsE630: .dw LsE6B2	; #0d #0a "Нет файлов" #0d #0a "$"
LsE632: .dw LsE6B2	; #0d #0a "Нет файлов" #0d #0a "$"  <<< 0DA05h, на "D"
LsE634: .dw LsE656	; "$"
LsE636: .dw LsE656	; "$"
;
LsE638: .db 0EFh	; <О>
	.db 0DBh	; <ш>
	.db 0C9h	; <и>
	.db 0C2h	; <б>
	.db 0CBh	; <к>
	.db 0C1h	; <а>
	.db 020h	; < >
	.db 0E2h	; <Б>
	.db 0F3h	; <С>
	.db 0F7h	; <В>
	.db 0F7h	; <В>
	.db 020h	; < >
	.db 0CEh	; <н>
	.db 0C1h	; <а>
	.db 020h	; < >
	.db 024h	; <$>
;
LsE647: .db 00Dh	; +++
	.db 00Ah	; +++
LsE648: .db 020h	; < >
	.db 0CFh	; <о>
	.db 0DBh	; <ш>
	.db 0C9h	; <и>
	.db 0C2h	; <б>
	.db 0CBh	; <к>
	.db 0C1h	; <а>
	.db 020h	; < >
	.db 0C4h	; <д>
	.db 0C9h	; <и>
	.db 0D3h	; <с>
	.db 0CBh	; <к>
	.db 0C1h	; <а>
	.db 024h	; <$>
;
LsE657: .db 020h	; < >
	.db 0C6h	; <ф>
	.db 0C1h	; <а>
	.db 0CAh	; <й>
	.db 0CCh	; <л>
	.db 020h	; < >
	.db 0D4h	; <т>
	.db 0CFh	; <о>
	.db 0CCh	; <л>
	.db 0D8h	; <ь>
	.db 0CBh	; <к>
	.db 0CFh	; <о>
	.db 020h	; < >
	.db 0C4h	; <д>
	.db 0CCh	; <л>
	.db 0D1h	; <я>
	.db 020h	; < >
	.db 0DEh	; <ч>
	.db 0D4h	; <т>
	.db 0C5h	; <е>
	.db 0CEh	; <н>
	.db 0C9h	; <и>
	.db 0D1h	; <я>
	.db 024h	; <$>
;
LsE66F: .db 020h	; < >
	.db 0D3h	; <с>
	.db 0C9h	; <и>
	.db 0D3h	; <с>
	.db 0D4h	; <т>
	.db 0C5h	; <е>
	.db 0CDh	; <м>
	.db 0CEh	; <н>
	.db 0D9h	; <ы>
	.db 0CAh	; <й>
	.db 020h	; < >
	.db 0C6h	; <ф>
	.db 0C1h	; <а>
	.db 0CAh	; <й>
	.db 0CCh	; <л>
	.db 024h	; <$>
;
LsE67F: .db 020h	; < >
LsE656:	.db 024h	; <$>
;
LsE852:	.db 02Eh	; <.> // 00Dh, 00Ah
LsE681: .db 0E9h	; <И>
	.db 0C7h	; <г>
	.db 0CEh	; <н>
	.db 0CFh	; <о>
	.db 0D2h	; <р>
	.db 0C9h	; <и>
	.db 0D2h	; <р>
	.db 0CFh	; <о>
	.db 0D7h	; <в>
	.db 0C1h	; <а>
	.db 0D4h	; <т>
	.db 0D8h	; <ь>
	.db 020h	; < >
	.db 028h	; <(>
	.db 059h	; <Y>
	.db 02Fh	; </>
	.db 04Eh	; <N>
	.db 029h	; <)>
	.db 03Fh	; <?>
	.db 020h	; < >
	.db 024h	; <$>
;
LsE696: .db 020h	; < >
	.db 0E6h	; <Ф>
	.db 0C1h	; <а>
	.db 0CAh	; <й>
	.db 0CCh	; <л>
	.db 020h	; < >
	.db 0D5h	; <у>
	.db 0D6h	; <ж>
	.db 0C5h	; <е>
	.db 020h	; < >
	.db 0C5h	; <е>
	.db 0D3h	; <с>
	.db 0D4h	; <т>
	.db 0D8h	; <ь>
	.db 024h	; <$>
;
S_E6A5: .db 00Dh	; +++ << 0C706h
	.db 00Ah	; +++
L_E6A7: .db 0EEh	; <Н>
	.db 0C5h	; <е>
	.db 0D7h	; <в>
	.db 0C5h	; <е>
	.db 0D2h	; <р>
	.db 0CEh	; <н>
	.db 0CFh	; <о>
	.db 0C5h	; <е>
	.db 020h	; < >
	.db 0C9h	; <и>
	.db 0CDh	; <м>
	.db 0D1h	; <я>
	.db 024h	; <$>
;
LsE6B2: .db 00Dh	; <_> << 0C706h
	.db 00Ah	; <_>
	.db 0EEh	; <Н>
	.db 0C5h	; <е>
	.db 0D4h	; <т>
	.db 020h	; < >
	.db 0C6h	; <ф>
	.db 0C1h	; <а>
	.db 0CAh	; <й>
	.db 0CCh	; <л>
	.db 0CFh	; <о>
	.db 0D7h	; <в>
L_E6BE: .db 00Dh	; <_>
	.db 00Ah	; <_>
	.db 024h	; <$>
;
LsE6C1: .db 00Dh	; <_> << 0C706h
	.db 00Ah	; <_>
	.db 0F5h	; <У>
	.db 0C4h	; <д>
	.db 0C1h	; <а>
	.db 0CCh	; <л>
	.db 0D1h	; <я>
	.db 0D4h	; <т>
	.db 0D8h	; <ь>
	.db 020h	; < >
	.db 028h	; <(>
	.db 059h	; <Y>
	.db 02Fh	; </>
	.db 04Eh	; <N>
	.db 029h	; <)>
	.db 03Fh	; <?>
	.db 020h	; < >
	.db 024h	; <$>
;
; =======================================
;L_E6DE: LXI  D, L_E6BE	; перевод строки
L_E6E1: MVI  C, 009h	; Вывод последовательности символов (до "$")
	JMP     00005h
;
L_E6EB:	LXI  D, A_005C	; первый аргумент выполняемой команды (нач.с нуля)
	MVI  C, 010h	; Закрытие файла
	JMP     00005h
;
;+++ команда "9" +++++++++++++++++++++++++++++++++++++++
P_Ex01:	LDA     A_0080	; ссылка на аргументы коммандной строки (<ДЛ>< ><строка><00h>)
	ANA  A
	JZ      LaD980	; переход, если ДЛ=0
	LXI  D, A_005C+1	; ссылка на аргументы коммандной строки (номер дискеты НЖМД)
	CALL    L_E4BA	; перевод в HEX и -> HL
	PUSH H		; в стек сохраняем номер дискеты
LxDMAX:	LXI  D, 0FFCFh	; это для проверки максимального значения, правится при старте системы
	DAD  D
	JC      La9ERR	; вывод "Неверное имя" и RET
	LDA     A_005C	; ссылка на аргументы коммандной строки (номер дискеты в системе)
	ANA  A
	JNZ     LaD931	; если не =0 (диск задан)
	LDA     A_0004	; считываем номер текущего диска
	INR  A		; +1
LaD931: DCR  A		; -1
	CPI     002h	; если это >= С:
	JNC     La9ERR	; вывод "Неверное имя" и RET
	PUSH PSW
	CALL    L_WBUF	; сброс дискового буфера, если требовалась запись
	POP  PSW	; восст. А (номер диска)
	MOV  E, A	; сохраняем номер диска -> E
	CMA		; инверсия
	ANI     001h	; выделяем первый бит
; поиск, не использована ли уже данная дискета?
	CALL    LaD9B2	; получение ссылки на таблицу замены дискеты на НЖМД
	POP  B		; восст. номер дискеты
	MOV  A, M
	CMP  C
	JNZ     LaD954	; не совпало
	INX  H
	MOV  A, M
	SUB  B		; вычитание вместо CMP, чтобы обнулить А в случае совпадения
	JNZ     LaD954	; не совпало
	MOV  M, A	; обнуление записи, если использована
	DCX  H		; --
	MOV  M, A	; --
LaD954: MOV  A, E	; восстанавливаем номер диска
	CALL    LaD9B2	; получаем ссылку на нужную таблицу
	MOV  M, C
	INX  H
	MOV  M, B
	INX  H		; запись в таблицу номера дискеты НЖМД
	PUSH H		; сохр.в стек
	LXI  H, 0F3BEh	; = 2 - 0622h * 2
	MVI  A, 0FFh
	INX  B
LaD96A: LXI  D, 00622h	; суммарное количество секторов на одной дискете
	DAD  D
	ACI     000h
	DCX  B
	MOV  D, A
	MOV  A, B
	ORA  C
	MOV  A, D
	JNZ     LaD96A
	XCHG
	POP  H		; читаем из стека адрес таблицы
	MOV  M, E	; сохр. мл. байт
	INX  H
	MOV  M, D	; сохр. ст. байт
	INX  H
	MOV  M, A	; сохр. ст.24 байт
LaDONE:	LXI  D, L_E6BE	; перевод строки
	JMP     L_E6E1	; Вывод последовательности символов (до "$") и RET
;
; ПП вывода текущей конфигурации
LaD980:	PUSH PSW	; сохр. номер диска
	ADI     041h	; A = A + 41h('A')
	STA     SaOUT1	; сохр. букву диска в строке
	LXI  D, SaOUT0	; строка <ПС>"A: $"
	CALL    L_E6E1	; Вывод последовательности символов (до "$")
	POP  PSW
	PUSH PSW
	CALL    LaD9B2	; получаем ссылку на нужную таблицу
	PUSH H
	INX  H
	CALL    LaDCB1	; вывод байта на экран из M(HL)
	POP  H
	CALL    LaDCB1	; вывод байта на экран из M(HL)
	POP  PSW
	INR  A		; Следующий диск
	CPI     002h
	JNZ     LaD980	; цикл...
	JMP     LaDONE	; Вывод перевода строки и RET
;
SaOUT0:	.db 00Dh
	.db 00Ah
SaOUT1:	.db "A: $"
;
LaDCB1:	MOV  A, M
	JMP     B_F815	; вывод байта на экран 16-ричном виде и RET
;	RET
;
LaD9B2: LXI  H, T_DrvA	; ПП получения ссылки на таблицу замены дискеты на НЖМД
	ANA  A
	RZ
	LXI  H, T_DrvB
	RET
;
La9ERR: POP  B		; подчистка стека
	JMP      L_E457	; вывод "Неверное имя" и RET
;
;============== подпрограммы для НЖМД + НГМД =========
#ifndef NoFDD
L_E709: MVI  C, 008h
L_E70B: PUSH B
	CALL    L_E8DF	; запись сектора ???
	POP  B
	RZ
	DCR  C
	JNZ     L_E70B
	RET
#endif
; сброс буфера НГМД на диск
L_IFHD:
#ifndef NoFDD
	LDA     L_E9A6	; чтение(04h)/запись(06h)
	ORA  A
	CNZ     L_E709	; сброс буфера на флопик, если не 0
	MVI  A, 0E2h
	STA     L_E99F	; предыдущий диск
	XRA  A
	STA     L_E9A6	; чтение(04h)/запись(06h) / 0 ???
#endif
;============== подпрограммы для НЖМД ================
; сброс буфера НЖМД на диск
L_WBUF:
#ifndef NoHDD
	LDA     L_RWD	; смотрим метку "требуется запись буфера"
	ANA  A		; признаки по А, A<>0 -- требуется запись.
	RZ      	; возврат если нет, иначе обращение к диску с предыдущими установками
#else
	RET
#endif
#ifndef NoHDD
;
; === ПП чтения/записи сектора НЖМД ===
; Вход:	L_E86F -- (сектор МДОС - 1)/4
;	L_1SEC -- ссылка на таблицу НЖМД +2 (номер первого сектора дисеты)
;	L_E86D -- дорожка МДОС
;	L_RWD  -- чтение(=0)/запись(=FFh)
; Вых.:	A и признак Z -- код ошибки
;	L_BDR -- дорожка, считанная в буфер
;	L_BSC -- (сектор-1)/4, считанный в буфер
;	L_BDS -- номер дискеты в буфере
;	L_E873 -- код возврата
;	
L_RWHD:
	LHLD    L_E86D	; дорожка, = FFh при инициализации НЖМД (чтении 1-го сектора)
	MOV  D, H
	MOV  E, L
	DAD  H
	DAD  H
	DAD  D
	DAD  H
	XCHG		; DE = дорожка * 10
	LHLD    L_E86F	; HL = (сектор-1)/4, = 0 при инициализации НЖМД (чтении 1-го сектора)
	DAD  D		; HL = дорожка * 10 + ((сектор-1)/4) (= 09F6h)
	LDA     L_E86D	; дорожка, = FFh при инициализации НЖМД (чтении 1-го сектора)
	CPI     008h
	JNC     L_D85F	; переход если дорожка >= 08h (несистемная область)
	LXI  D, 00002h
	XRA  A
	JMP     L_D86C
;
L_D853:	CPI     0FFh
	LXI  D, 0F60Ah	; = -09F6h
	JZ      L_D86C
	JMP     L_D9F8	; получение кода ошибки и RET
;
L_D85F:	CPI     0A5h	; максимальный номер дорожки 0A4h
	JNC     L_D853
	PUSH H		; в стек HL = дорожка * 10 + (сектор-1)/4
	LHLD    L_1SEC	; загрузка в HL ссылки на таблицу НЖМД +2
	MOV  E, M
	INX  H
	MOV  D, M
	INX  H
	MOV  A, M	; (A,DE)=(номер первого сектора дискеты)
	POP  H		; HL = (номер сектора) = дорожка * 10 + (сектор-1)/4
L_D86C:	DAD  D
	ACI     000h	; (A,HL) = (номер сектора) + (номер первого сектора дискеты) = 00 0000h
	OUT     055h	; LBA [23..16]
	MOV  A, L
	OUT     053h	; LBA [7..0]
	MOV  A, H
	OUT     054h	; LBA [15..8]
	MVI  A, 0E0h	; 1110 0000
	OUT     056h	; режим и LBA[27..24]
	MVI  A, 001h	; количество читемых/записываемых секторов
	OUT     052h	; Счетчик числа секторов для операции чтения/записи
	LDA     L_RWD	; чтение(=0)/запись(=FFh)
	MOV  E, A	; сохр.режим в Е
	ANA  A		; установка признака Z по А
	MVI  A, 020h	; 2xH = сектор чтения (x = retry and ECC-read)
	JZ      L_D8A9	; -> если чтение
	MVI  A, 030h	; 3xH = сектор записи (x = retry and ECC-read)
L_D8A9:	OUT     057h	; Запись:	регистр команды
	LXI  H, D_EB00	; адрес буфера для чтения/записи данных
	CALL    L_D9D9	; проверка готовности НЖМД
	ANI     008h	; 0000 1000 :	запрос данных. Буфер ждет данных (занято)
	JZ      L_D9F9	; получение кода ошибки 2 и RET
	MVI  D, 000h	; D=0
	INR  E		; просто установка признака Z по значению E
	DCR  E
	JNZ     L_D8CF	; -> запись сектора
			; чтение сектора НЖМД
L_D8C1:	IN      050h	; Регистр данных. Чтение данных в буфер
	MOV  M, A
	INX  H
	IN      058h	; Регистр данных. Чтение данных в буфер
	MOV  M, A
	INX  H
L_D8Cx:	DCR  D		; счётчик
	JNZ     L_D8C1	; цикл
	JMP     L_D8DC	; выход из чтения
;
L_D8CF:	MOV  E, M	; запись сектора
	INX  H
	MOV  A, M
	OUT     058h	; Регистр данных. Запись данных из буфера
	MOV  A, E
	OUT     050h	; Регистр данных. Запись данных из буфера
	INX  H		; цикл записи
L_D8D8:	DCR  D		; счётчик
	JNZ     L_D8CF	; цикл
L_D8DC:	CALL    L_D9D9	; проверка готовности НЖМД
	ANI     0DDh	; 1101 1101 -- маскируем лишьнее
	MOV  C, A	; сохраняем код возврата в C
	ANI     008h	; 0000 1000 :	Буфер ждет данных (занято)
	JZ      L_D8xx	; если не занято
	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate)
	OUT     057h	; Запись:	регистр команды
L_D8xx:	MOV  A, C
	ANI	0D5h	; 1101 0101 -- маскируем "Буфер ждет данных (занято)"
	SUI     050h	; минус норм. код возврата
	JNZ     L_D9F9	; (<> 50h) & (<> 58h) -> получение кода ошибки 2 и RET
	STA     L_E873	; сохраняем код возврата (=0)
	STA     L_RWD	; метка "требуется запись буфера" (всегда нет = 0)
	LDA     L_E86D
	STA     L_BDR	; дорожка в буфере
	LDA     L_E86F
	STA     L_BSC	; (сектор-1)/4 в буфере
	LHLD    L_DSKT
	SHLD    L_BDS	; сохраняем номер дискеты
	RET		; >>>>>>>>>> выход из ПП c Z=1
;
; ПП проверки готовности НЖМД
L_D9D9:	PUSH D
	PUSH B
	MVI  D, 005h	; пять раз...
L_D9DD:	IN      057h	; регистр статуса
	ANI     0C0h	; 1100 0000
	CPI     040h	; 0100 0000 устройство готово к операции
	JZ      L_D9F2	; >> выход из цикла, при выходе A=40h
	DCX  B
	MOV  A, B
	ORA  C
	JNZ     L_D9DD	; цикл на 65536 попыток
	DCR  D
	JNZ     L_D9DD	; цикл на 5*65536 попыток, при выходе A,B,C,D=0
L_D9F2:	ANA  A		; устанавливаем признаки по А
	POP  B
	POP  D
	JZ      L_D9F8	; получение кода ошибки и RET
	IN      057h	; регистр статуса
	RET
;
; ПП чтения ошибки
L_D9F8:	POP  PSW	; чистка стека
L_D9F9:	IN      057h	; регистр статуса
	RRC		; сдвиг вправо, бит 0 заносится в признак С.
	IN      051h	; Чтение:	Регистр ошибок. Содержит признаки последней ошибки.
	JC      L_DA02	; если предыдущая команда закончилась с ошибкой
	XRA  A		; ошибки нет
L_DA02:	MOV  B, A	; В = код ошибки
	IN      057h	; регистр статуса
	MOV  C, A	; сохраняем результат
	ANI     020h	; выделяем ошибку "сбой записи"
	ORA  B
	MOV  B, A	; дополняем код ошибки в В
	MOV  A, C	; восст. Регистр данных.
	ANI     0C0h	; выделение сигналов "устройство готово" и "занято"
	CPI     040h	; уст.Z если "готово"
	MOV  A, B	; код ошибки в А
	JZ      L_E6AB	; переход, если сигнал "готово" (?было на L_DA15)
	MVI  A, 010h	; 1xH = сброс на цилиндр 0 (x = step rate) (?было ORI)
xxDA15:	OUT     05Fh	; Системный сброс (лучше не пользоваться, сходство с 57Н без обнуления микросхем жесткого диска).
L_E6AB:	STA     L_E873	; сохраняем код ошибки
	ANA  A		; устанавливаем признаки по ошибке
	RET
#endif
;
;============== подпрограммы для флопов ================
L_E716:
#ifdef NoFDD
	ORI  0FFh
	RET		; нет драйвера флоповодов -- возвр.ошибку
#else
	LDA     L_E98C	; чтение(04h)/запись(06h)
	CPI     004h	; обращение к флопикам: чтение(04h)/запись(06h)
	JZ      L_E775	; чтение сектора ФД в дисковый буфер
	LDA     L_E990+1	; адрес буфера дисковой операции, ст.байт
	CPI     0EAh	; дисковый буфер в 0EAxxh?
	JZ      L_E775	; чтение сектора ФД в дисковый буфер
	LHLD    L_E9A3	; тут лежит (Дорожка * 256 + ((Сектор-1)/8)) с прошлой записи
	LDA     L_E98F	; сектор
	DCR  A		; -1
	ANI     0F8h	; 1111 1000
	RRC
	RRC
	RRC
	MOV  E, A	; (сектор-1)/8
	CMP  L
	LDA     L_E98E	; дорожка
	MOV  D, A	; DE = (Дорожка * 256 + ((Сектор-1)/8))
	JNZ     L_E74E	; если (Сектор <> L)
	CMP  H
	JNZ     L_E74E	; если (Дорожка <> H)
	LDA     L_E98A	; диск
	MOV  C, A
	LDA     L_E99F	; диск с прошлой записи
	CMP  C
L_E74E:	XCHG
	SHLD    L_E9A3	; сохраняем (Дорожка * 256 + ((Сектор-1)/8))
	JNZ     L_E775	; чтение сектора ФД в дисковый буфер
	LDA     L_E9A2	; счётчик секторов ???
	ANA  A
	JZ      L_E77D	; = 0 ? >>
	DCR  A		; счётчик-1
	STA     L_E9A2	; счётчик секторов ???
	JNZ     L_E77D	; <> 0 ? >>
	STA     L_E9A5	; счётчик секторов ???
	JMP     L_E77D	; >>
;
L_E775: MVI  A, 010h	; ПП чтения сектора ФД в дисковый буфер
	STA     L_E9A2	; счётчик секторов ???
	STA     L_E9A5	; счётчик секторов ???
	LDA     L_E98F	; сектор
	DCR  A		; -1
	ANI     0F8h	; 1111 1000
	RRC
	RRC
	RRC
	MOV  L, A
L_E77D:	MOV  A, L
	STA     L_E9A7	; (сектор-1)/8
	LXI  H, L_E9A1	; (сектор-1)/8 в буфере (?)
	CMP  M
	JNZ     L_E7AE	; не совпало >>
	LDA     L_E98E	; дорожка
	LXI  H, L_E9A0	; дорожка в буфере (?)
	CMP  M
	JNZ     L_E7AE	; не совпало >>
	LDA     L_E98A	; диск
	LXI  H, L_E99F	; диск с прошлой записи
	CMP  M
	JNZ     L_E7AE	; не совпало >>
	LDA     L_E9AB	; RC
	ANA  A
	JZ      L_E7D6	; >>
	JMP     L_E7BC	; >>
;
L_E7AE: LDA     L_E9A6	; чтение(04h)/запись(06h)
	ORA  A
	JZ      L_E7BC	; если чтение/запись = 0
	CALL    L_E8DF	; запись сектора ???
	RNZ		; RET>>
	STA     L_E9A6	; чтение(04h)/запись(06h), обнуляется?
L_E7BC: LDA     L_E98A	; диск
	STA     L_E99F	; сохраняем диск для следующей операции
	LHLD    L_E98E	; дорожка
	SHLD    L_E9A0	; дорожка в буфере (?)
	LDA     L_E9A7	; (сектор-1)/8
	STA     L_E9A1	; (сектор-1)/8 в буфере (?)
	LDA     L_E9A5
	ANA  A
	CNZ     L_E8A7	; чтение сектора ???
	RNZ		; RET>>
L_E7D6:	LXI  D, D_FD_B	;0EB00h	; ------------
	LDA     L_E98F	; сектор
	DCR  A
	ANI     007h
	RAR
	MOV  H, A
	MVI  A, 000h
	RAR
	MOV  L, A
	DAD  D		; HL -- начало данных в буфере для переброски
	LDA     L_E98C	; чтение(04h)/запись(06h)
	CPI     006h
	JNZ     L_E7F8	; НЕ запись
	STA     L_E9A6	; сохр.чтение(04h)/запись(06h)
L_E7F8: CALL    L_MBUF	; переброска данных из/в дисковый буфер МДОС
	LDA     L_E9AB	; RC
	ANA  A
	RET
;
; =============================     ===========
L_E826: LDA     L_E99F	; диск с прошлой записи
	ANI     003h
	MOV  C, A
	LDA     L_E9A0	; дорожка в буфере (?)
	RRC
	MVI  A, 004h
	JNC     L_E836
	XRA  A
L_E836: ORA  C
	MOV  B, A
	ORI     030h
	STA     L_E9AA
	MVI  E, 004h	; выставляем счётчик на отсутствие дискеты
L_E83E: IN      01Bh	; регистр состояния (IN)
	RLC
	JNC     L_E853	; >>
	MOV  A, B
	OUT     01Ch	; регистр управления
	LXI  H, 00000h	; XXX <<-- меняется !!!
L_E84A: DCX  H
	MOV  A, H
	ORA  L
	JNZ     L_E84A	; цикл ожидания, 65536 раз.
	DCR  E
	JNZ     L_E83E	; повтор, если цикл был меньше 4 раз
LeE852:	PUSH B
	LXI  D, LsE647	; <ПС>" ошибка диска"
	CALL    L_E6E1	; Вывод последовательности символов (до "$")
	LXI  D, LsE852	; вопрос...
	CALL    L_E6E1	; Вывод последовательности символов (до "$")
	MVI  C, 001h
	CALL    00005h	; ввод одного символа
	POP  B
	CPI     04Eh	; == 'N'?
	JZ      O_C003	; сброс
	CPI     059h	; == 'Y'?
	JZ      L_E83E	; повтор
	JMP     LeE852	; не понял ответ...
;
L_E853: MOV  A, B
	OUT     01Ch	; регистр управления
	LXI  H, L_E9A8
	LDA     L_E99F	; диск с прошлой записи
	ANI     001h
	JZ      L_E862
	INX  H
L_E862: MOV  A, M
	RAR
	OUT     01Ah	; регистр дорожки
	LDA     L_E9A0	; дорожка в буфере (?)
	MOV  M, A
	ANA  A
	RAR
L_E86C: DI
	OUT     018h	; регистр данных
LxE86F: MVI  A, 010h	; 0001 0000 = поиск <--- меняется ХХХ
	OUT     01Bh	; регистр команд (OUT)
	CALL    L_E884
L_E876: MOV  A, B
	OUT     01Ch	; регистр управления
	IN      01Bh	; регистр состояния (IN)
	RRC
	JC      L_E876
	LDA     L_E9AA
	OUT     01Ch	; регистр управления
L_E884: MVI  A, 0FAh
	MVI  C, 002h
L_E888: SUB  C
	JNZ     L_E888
	RET
;
L_E88D: XRA  A		; 0000 0000 = сброс
	OUT     01Bh	; регистр команд (OUT)
	CALL    L_E884
L_E893: MOV  A, B
	OUT     01Ch	; регистр управления
	IN      01Bh	; регистр состояния (IN)
	RRC
	JC      L_E893
	CALL    L_E884
	LDA     L_E9A0	; дорожка в буфере (?)
	ANA  A
	RAR
	JMP     L_E86C
;
; ======== ПП чтения сектора ===========================
L_E8A7: CALL    L_E826	; >> проверка готовности и установка дорожки
	LDA     L_E9A1	; (сектор-1)/8 в буфере (?)
	INR  A
	OUT     019h	; регистр сектора
	MVI  A, 080h	; 1000 0000 = читать один сектор, нижняя сторона
	OUT     01Bh	; регистр команд (OUT)
	LXI  D, D_FD_B	;0EB00h	; ---------------
	LXI  H, L_E8CE	; адрес возврата из цикла
	PUSH H
	LXI  H, L_E8C1	; = PCHL (2) =
	CALL    L_E884	; >>
L_E8C1: IN      01Bh	; регистр состояния (IN)
	RRC
	RNC		; выход из цикла > L_E8CE
	RRC
	JNC     L_E8C1
	IN      018h	; регистр данных
	STAX D
	INX  D
	PCHL		; (2) >>> L_E8C1
;
L_E8CE: LDA     L_E9AA	; <<<
	OUT     01Ch	; регистр управления
	IN      01Bh	; регистр состояния (IN)
	ANI     0DFh	; 1101 1111
L_E8Cz:	STA     L_E9AB	; RC
	ANA  A
	EI
	RZ		; выход >>--
	ANI     010h	; обработка ошибок...
	CNZ     L_E88D
	LDA     L_E9AB	; RC
	ANA  A
	RET
;
; ======== ПП записи сектора =============================
L_E8DF: CALL    L_E826	; проверка готовности ????
	LXI  H, L_E91E	; адрес возврата из цикла
	PUSH H		;
	LXI  H, L_E8F9	; = PCHL (3) =
	LXI  D, D_FD_B	;0EB00h	; -------------
	LDA     L_E9A1	; (сектор-1)/8 в буфере (?)
	INR  A
	OUT     019h	; регистр сектора
	MVI  A, 0A0h	; 1010 0000 = писать один сектор, нижняя сторона
	OUT     01Bh	; регистр команд (OUT)
	CALL    L_E884
L_E8F9: IN      01Bh	; регистр состояния (IN)
	ANA  C
	JNZ     L_E919
	IN      01Bh	; регистр состояния (IN)
	ANA  C
	JNZ     L_E919
	IN      01Bh	; регистр состояния (IN)
	ANA  C
	JNZ     L_E919
	IN      01Bh	; регистр состояния (IN)
	ANA  C
	JNZ     L_E919
	IN      01Bh	; регистр состояния (IN)
	RRC
	RNC		; >>>> ------
	RRC
	JZ      L_E8F9
L_E919: LDAX D
	OUT     018h	; регистр данных
	INX  D
	PCHL		; (3) >>> L_E8F9
;
L_E91E: LDA     L_E9AA	; <<< из цикла
	OUT     01Ch	; регистр управления
	IN      01Bh	; регистр состояния (IN)
	JMP     L_E8Cz	; обработка ошибок и выход
;
#endif
; =============== конец ПП для флопов ===============
;
;<< обращение из 0D6DEh (2)
D_E935: .dw 00028h	; SPT - количество секторов (по 128 байт) на дорожку;
	.db 004h	; BSH - количество бит, на которое необходимо сдвинуть размер логического сектора, чтобы получить размер кластера
	.db 00Fh	; BLM - маска кластера - (размер_кластера/128)-1;
	.db 000h	; ЕХМ - маска директорной записи: если ЕХМ=0, то максимальный размер, адресуемый одной директорной записью, равен 16К; если ЕХМ=1, то - 32К и т.д.
	.dw 00187h	; DSM - объем памяти на диске в блоках минус 1 (не считая системных дорожек)
	.dw 0007Fh	; DRM - количество входов в директорию -1
	.db 0C0h	; AL0,1 - битовая шкала занятости BLS директорией. Начало шкалы - бит 7 AL0, конец - бит 0 AL1. Количество единиц, заполняющих AL0,1 (от начала шкалы) - (DRM+BLS/32)/(BLS/32).
	.db 000h	; // определяет, какие блоки зарезервированы
			; // под директорию. Каждый  бит AL0,AL1, 
			; // начиная со старшего бита AL0 и кончая 
			; // младшим битом AL1, значением 1 резервирует
			; // один блок данных для директории. Нужно
			; // резервировать необходимое число блоков
			; // для хранения входов в директорию: 32*DRM/BLS
	.dw 00020h	; CKS - размер области CSV в DPH. Для сменных дисков - (DRM+1)/4, для не сменных - 0.
	.dw 00008h	; OFF - количество зарезервированных дорожек на диске (с системой например). 
;
D_E953: .dw 00008h	; SPT	; << обращение из 0D6DEh (КД)
	.db 003h	; BSH
	.db 007h	; BLM
	.db 000h	; EXM
	.dw 000EBh	; DSM	; = 236 кластеров, 2КД = 472 (001D7h)
	.dw 0003Fh	; DRM	; = 64 записи, 2КД = 128 (0007Fh)
	.db 0C0h	; AL0
	.db 000h	; AL1
	.dw 00000h	; CKS
	.dw 00000h	; OFF
;
; сюда копируется описатель дисковой операции из DDFOh (флопы/НЖМД/КД):
L_E98A: .db 000h	; номер диска (для КД >= 2)
	.db 000h	; ?? =80h
L_E98C: .db 000h	; чтение(04h)/запись(06h)
	.db 000h	; ?? =01h
L_E98E: .db 000h	; номер дорожки диска
L_E98F: .db 000h	; номер сектора диска
L_E990: .dw 00000h	; адрес буфера для дисковых операций
;
L_E992: .dw 00000h	; << адрес сектора КД
L_E994: .db 000h	; конфиг.КД
L_E995: .dw 00000h	; << адрес контрольной суммы сектора КД
;
; НЖМД:
#ifndef NoHDD
L_DSKT:	.dw 00000h	; дискета НЖМД (запрос)
L_1SEC:	.dw T_DrvA+2	; ссылка на номер первого сектора дискеты из таблицы НЖМД
L_E86D:	.dw 00000h	; дорожка, = FFh при инициализации НЖМД (чтении 1-го сектора)
L_E86F:	.dw 00000h	; (сектор-1)/4, = 0 при инициализации НЖМД (чтении 1-го сектора)
L_BDS:	.dw 0FF00h	; дискета	(данных в буфере)
L_BDR:	.db 000h	; дорожка	(данных в буфере)
L_BSC:	.db 000h	; (сектор-1)/4	(данных в буфере)
L_RWD:	.db 000h	; чтение(=0)/запись(=FFh); метка "требуется запись буфера", да =FFh
L_E873:	.db 000h	; код ошибки при выходе из ПП чтения/записи
#endif
;
; (флопы):
#ifndef NoFDD
L_E99F: .db 000h	; диск с прошлой записи -- Е2
L_E9A0: .db 000h	; дорожка
L_E9A1: .db 000h	; (сектор-1)/8
L_E9A2: .db 010h	; <_> - |   ■    |
L_E9A3: .dw 00000h	; текущее значение (Дорожка * 256 + ((Сектор-1)/8))
L_E9A5: .db 010h	; <_> - |   ■    |
L_E9A6: .db 000h	; чтение(04h)/запись(06h)
L_E9A7: .db 000h	; (сектор-1)/8
L_E9A8: .db 001h	; <_> - |       ■|
	.db 004h	; <_> - |     ■  |
L_E9AA: .db 000h	; <_> - |        |
L_E9AB: .db 000h	; результат выполнения команды ????
#endif
;
; Таблицы для НЖМД
T_DrvA: .dw 00001h	; номер дискеты в HEX
	.dw 00002h	; номер первого сектора в HEX, мл.разряд 24bit
	.db 000h	; номер первого сектора в HEX, ст.разряд 24bit
T_DrvB: .dw 00005h	; номер дискеты в HEX
	.dw 0188Ah	; номер первого сектора в HEX, мл.разряд 24bit
	.db 000h	; номер первого сектора в HEX, ст.разряд 24bit
;
; далее идут дисковые буферы (заданы по define в начале)
; должно быть <= 0EA06h+512 = 0EC06h
D_E9AC:	.db 000h
#if ($ > (S_FONT-0367h))
	; выдаёт ошибку в случае превышения допустимого размера
	.ECHO "ПЕРЕПОЛНЕНИЕ !!! "
	!!!
#endif
;	.dw S_FONT-(D_EB00+512)	; >=0 -- для проверки
	.END
